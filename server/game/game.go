package game

type position = uint16

type fieldSize struct {
	x position
	y position
}

var Settings = struct {
	TickRate    uint8
	FieldSize   fieldSize // dimensions of the field
	PlayerSpeed position  // pixels traveled per tick
}{
	TickRate:    60,
	FieldSize:   fieldSize{300, 300},
	PlayerSpeed: 10,
}

////////////////////////////////////////////////////////////////////////////////

type playerId = string

type player struct {
	id playerId
	x  position
	y  position
}

////////////////////////////////////////////////////////////////////////////////

type timestamp = uint64

type inputState struct {
	up    bool
	down  bool
	left  bool
	right bool
}

// Generated by the game engine,
type GameEvent struct {
	timestampMs timestamp
	playerId    playerId
	inputState  inputState
}

////////////////////////////////////////////////////////////////////////////////

/* TODO:
client sends only input state and timestamp
*/

type players = map[playerId]*player

type Game struct {
	players players
}

func New() *Game {
	return &Game{
		players: players{},
	}
}

/* Set the fields of Game, given a queue of GameEvents */
func (g *Game) Update(events []GameEvent) {
	// TODO: set properties of game...
	// TODO: process PRE-SORTED inputs
	// TODO: update player positions
	for _, e := range events {
		// TODO: does this cause a race condition?
		if e.inputState.up {
			g.players[e.playerId].y += Settings.PlayerSpeed
		}
		if e.inputState.down {
			g.players[e.playerId].y -= Settings.PlayerSpeed
		}
		if e.inputState.left {
			g.players[e.playerId].x += Settings.PlayerSpeed
		}
		if e.inputState.right {
			g.players[e.playerId].x -= Settings.PlayerSpeed
		}
	}
	// TODO: stop movement past field bounds

	// ... hub will serialize and send, and handle closing the event channel
}
