package game

import (
	"log"
	"math/rand/v2"

	"github.com/google/uuid"
)

type position = int

type size struct {
	W position `json:"w"`
	H position `json:"h"`
}

var SETTINGS = struct {
	TickRate    uint8
	FieldSize   size // dimensions of the field
	SpriteSize  size
	PlayerSpeed position // pixels traveled per tick
}{
	TickRate:    60,
	FieldSize:   size{800, 800},
	SpriteSize:  size{60, 60},
	PlayerSpeed: 7,
}

const PALETTE_24BIT_LEN = 24

// thank you, Claude
var PALETTE_24BIT = [PALETTE_24BIT_LEN]uint32{
	0xF2C5B8, 0xE8A5A5, 0xF0A0E0, 0xB584F5, 0xF06A8A, 0xE8809A,
	0xF8A060, 0xF5D580, 0x80E080, 0x70D8C8, 0x60C8E8, 0x50B8E8,
	0x60A0F8, 0x9090F8, 0xB8C0F0, 0xA0A8D8, 0xFF6B6B, 0xFF8E53,
	0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFFEAA7, 0xDDA0DD, 0x20B2AA,
}

////////////////////////////////////////////////////////////////////////////////

type PlayerId = string

type Player struct {
	Id     PlayerId `json:"id"`
	Color1 uint32   `json:"color1"` // 0x 00 FF FF FF -> most significant pair = 00 for 24 bit color.
	Color2 uint32   `json:"color2"` // if most signficant pair is used, least signficant pair becomes opacity
	Color3 uint32   `json:"color3"`
	X      position `json:"x"`
	Y      position `json:"y"`
}

func NewPlayer() *Player {
	return &Player{
		Id:     uuid.New().String(),
		Color1: PALETTE_24BIT[rand.Uint32N(PALETTE_24BIT_LEN)],
		Color2: PALETTE_24BIT[rand.Uint32N(PALETTE_24BIT_LEN)],
		Color3: PALETTE_24BIT[rand.Uint32N(PALETTE_24BIT_LEN)],
		X:      SETTINGS.FieldSize.W/2 - SETTINGS.SpriteSize.W/2,
		Y:      SETTINGS.FieldSize.H/2 - SETTINGS.SpriteSize.H/2,
	}
}

type players = map[PlayerId]*Player

////////////////////////////////////////////////////////////////////////////////

type timestamp = uint64

type inputState struct {
	Up    bool `json:"up"`
	Down  bool `json:"down"`
	Left  bool `json:"left"`
	Right bool `json:"right"`
}

// Generated by the game engine,
type GameEvent struct {
	TimestampMs timestamp  `json:"timestampMs"`
	PlayerId    PlayerId   `json:"playerId"`
	InputState  inputState `json:"inputState"`
}

////////////////////////////////////////////////////////////////////////////////

type Game struct {
	Players players `json:"players"`
}

func New() *Game {
	return &Game{
		Players: players{},
	}
}

func (g *Game) AddPlayer(p *Player) {
	g.Players[p.Id] = p
	// DEBUG
	log.Println("Added player:", p.Id)
}

func (g *Game) RemovePlayer(playerId PlayerId) {
	delete(g.Players, playerId)
	// DEBUG
	log.Println("Removed player:", playerId)
}

/*
Set the fields of Game, given a queue of GameEvents
TODO: pre-sort inputs?
TODO: sprite:sprite collision detection
*/
func (g *Game) Update(e GameEvent) {
	player := g.Players[e.PlayerId]
	speed := SETTINGS.PlayerSpeed
	fieldSize := SETTINGS.FieldSize
	spriteSize := SETTINGS.SpriteSize

	// NOTE: inverted directions like css
	if e.InputState.Up {
		player.Y = max(player.Y-speed, 0)
	}
	if e.InputState.Down {
		player.Y = min(player.Y+speed, fieldSize.H-spriteSize.H)
	}
	if e.InputState.Left {
		player.X = max(player.X-speed, 0)
	}
	if e.InputState.Right {
		player.X = min(player.X+speed, fieldSize.H-spriteSize.H)
	}
}
