package game

import "log"

type position = int

type fieldSize struct {
	x position
	y position
}

var Settings = struct {
	TickRate    uint8
	FieldSize   fieldSize // dimensions of the field
	PlayerSpeed position  // pixels traveled per tick
}{
	TickRate:    60,
	FieldSize:   fieldSize{300, 300},
	PlayerSpeed: 5,
}

////////////////////////////////////////////////////////////////////////////////

type playerId = string

type Player struct {
	Id playerId `json:"id"`
	X  position `json:"x"`
	Y  position `json:"y"`
}

func NewPlayer(id playerId) *Player {
	return &Player{
		Id: id,
		X:  0,
		Y:  0,
	}
}

type players = map[playerId]*Player

////////////////////////////////////////////////////////////////////////////////

type timestamp = uint64

type inputState struct {
	Up    bool `json:"up"`
	Down  bool `json:"down"`
	Left  bool `json:"left"`
	Right bool `json:"right"`
}

// Generated by the game engine,
type GameEvent struct {
	TimestampMs timestamp  `json:"timestampMs"`
	PlayerId    playerId   `json:"playerId"`
	InputState  inputState `json:"inputState"`
}

////////////////////////////////////////////////////////////////////////////////

/* TODO:
client sends only input state and timestamp
*/

type Game struct {
	Players players `json:"players"`
}

func New() *Game {
	return &Game{
		Players: players{},
	}
}

func (g *Game) AddPlayer(playerId string) {
	log.Println("Added player:", playerId)
	g.Players[playerId] = NewPlayer(playerId)
}

func (g *Game) RemovePlayer(playerId string) {
	log.Println("Removed player:", playerId)
	delete(g.Players, playerId)
}

/* Set the fields of Game, given a queue of GameEvents */
func (g *Game) Update(e GameEvent) {
	// TODO: set properties of game...
	// TODO: process PRE-SORTED inputs
	// TODO: update player positions
	// TODO: does this cause a race condition?

	// log.Println("GAME EVENT:", e)

	// NOTE: inverted directions like css
	if e.InputState.Up {
		g.Players[e.PlayerId].Y -= Settings.PlayerSpeed
	}
	if e.InputState.Down {
		g.Players[e.PlayerId].Y += Settings.PlayerSpeed
	}
	if e.InputState.Left {
		g.Players[e.PlayerId].X -= Settings.PlayerSpeed
	}
	if e.InputState.Right {
		g.Players[e.PlayerId].X += Settings.PlayerSpeed
	}
	// TODO: stop movement past field bounds

	// ... hub will serialize and send, and handle closing the event channel
	// log.Println("UPDATED GAME STATE")
}
